/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package arm.apriori.core;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;



/**
 * This class represents the Apriori Algorithm.
 *
 * @author Benjamin Bouvier
 *
 */
public class AprioriAlgorithm {

	// The data source of the transactions. It's an object that can generate a
	// list of transactions.
	protected TransactionSource source;
        List Open =new LinkedList();
        List Closed =new LinkedList();

	// The transactions generated by the source
	public List<Itemset> transactions;
        public List<Itemset> Freq = new ArrayList<Itemset>();
       public  List<Itemset> Specific = new ArrayList<Itemset>();
         public List<Itemset> General = new ArrayList<Itemset>();
         public List<Itemset> centers = new ArrayList<Itemset>();
        int []S=new int[10000];

	// A link to the GUI, so as to log informations.
	protected NewClass gui;

	/**
	 * Logs an information in the GUI.
	 *
	 * @param s
	 *            String to be logged
	 */
	protected void log(String s) {
	//	gui.log(s);
	}

	/**
	 * Public setter for Source, used by the GUI, when the user clicks on one
	 * button.
	 *
	 * Reinits all elements of the algorithm and saves the source.
	 *
	 * @param transactionSource
	 *            A source of transactions.
	 */
	public void setSource(TransactionSource transactionSource) {
		LabelsMap.getInstance().clear();
		SupportMap.clear();
		source = transactionSource;
	}

	/**
	 * Generates the transactions from the source and logs them in the GUI.
	 *
	 * @return
	 */
	public List<Itemset> getTransactions() {
		transactions = source.generate();
            /*    transactions=new ArrayList<Itemset>();
                for (int i=0;i<100;i++)
                {
                    Random r=new Random();
                    int x=r.nextInt(20);
                    Itemset e=new Itemset();
                for (int j=0;j<x;j++)
                {
                
                e.add(r.nextInt(20));
                }
                     transactions.add(e);

                }*/
		/*System.out.println("The following transactions have been loaded: ");
		for (Itemset i : transactions) {
			System.out.println("\t> " + i);
		}
             */
             
		return transactions;
	}

	/**
	 * The APriori Algorithm itself.
	 *
	 * Frequent itemsets of size N are said here to belong to the level N.
	 *
	 * The important steps of the algorithms are the following: 1) Computes
	 * support and keep frequent itemsets of size 1. 2) Continue to generate new
	 * itemsets while we have at least 2 different itemsets in the previous
	 * level of itemsets. 3) Once we computed all the frequent itemsets,
	 * generate all the rules.
	 *
	 * The generation of new itemsets of size N+1 from the frequent itemsets of
	 * size N: - join step: let's take 2 different itemsets of size N with a
	 * common prefix of size N-1 and mix them to form an itemset I_NEW of size
	 * N+1. - prune step: check that all N-subsets of I_NEW are frequent
	 * (APriori principle). - if I_NEW is possible, checks its support value
	 * according to the support threshold.
	 *
	 * @param support
	 *            the threshold value of support
	 * @param confidence
	 *            the threshold value of confidence
	 * @return A list of valid rules satisfying both support and confidence
	 *         thresholds.
	 */
	public List<Itemset> run(int support, int confidence) {

		log("Launching A Priori algorithm with following parameters:");
		log("Support (absolute) min: " + support);
		log("Confidence min: " + confidence);

		double begin = System.currentTimeMillis(); // for performance analysis
													// only

		// let's register the transactions in the support map
		SupportMap.setup(transactions);

		// Step 1 of the algorithm: generate frequent 1-itemsets
		log("Computing frequents of size 1...");
		List<Itemset> previousLevel = new ArrayList<Itemset>();
		for (int i : LabelsMap.getInstance().getAllProducts()) {
			Itemset temp = new Itemset();
			temp.add(i);

			int itemSupport = temp.getRelativeSupport();
			log("\t> Item: " + temp + " (support: " + itemSupport + ")");

			if (itemSupport >= support) {
				log("\t\t=> This item is a frequent itemset of size 1.");
				previousLevel.add(temp);
			} else {
				log("\t\t=> This item isn't a frequent itemset of size 1.");
			}
		}

		// Step 2: generate frequent itemsets of higher size
		log("Computing frequents of higher size...");
		List<Itemset> allFrequents = new ArrayList<Itemset>(previousLevel);
		List<Itemset> nextLevel = null;
		int level = 1; // level is incremented just at the beginning of the
						// while loop
		while (previousLevel.size() >= 2) {
			log("\t> Computing frequents of size " + ++level);
			// level == N+1 is the size of itemsets we want to generate.

			// reinits next level elements. Next level elements are here
			// elements of the size N+1.
			nextLevel = new ArrayList<Itemset>();

			for (int i = 0, s = previousLevel.size(); i < s; ++i) {
				Itemset is1 = previousLevel.get(i); // is1 is one itemset of
													// size N-1
				for (int j = i + 1; j < s; ++j) {
					Itemset is2 = previousLevel.get(j); // is2 is another
														// itemset of size N-1
					// We need to know whether is1 and is2 share the same
					// prefix; for this, we put
					// all elements of is2 in a list and remove the last
					// element. The list is the prefix
					List<Integer> prefix = new ArrayList<Integer>(is2);
					int last = prefix.remove(prefix.size() - 1);

					// The generated itemset is is1 with the last element of is2
					Itemset generated = new Itemset(is1);
					generated.add(last);
					if (!SupportMap.alreadyProcessed(generated)) {
						// first condition: checks that is1 share contains the
						// prefix, i.e. is1 and is2 have the same prefix
						// second condition: checks that all subsets of size N-1
						// of the generated element are frequent (APriori
						// principle)
						if (is1.containsAll(prefix)
								&& previousLevel.containsAll(generated
										.subsetWithoutOneElement())) {
							int generatedSupport = generated
									.getRelativeSupport();
							log("\t\t>> Generated itemset: " + generated
									+ " (support: " + generatedSupport + ")");
							// checks the support
							if (generatedSupport >= support) {
								log("\t\t\t>> Frequent itemset.");
								nextLevel.add(generated);
							} else {
								log("\t\t\t>> Not frequent.");
							}
						}
					}
				}
			}
			// All itemsets in nextLevel are frequent and of size N+1
			allFrequents.addAll(nextLevel);
			log("\t> All the frequent itemsets of size " + level
					+ " are the following: ");
			for (Itemset itemset : nextLevel) {
				log("\t\t>> " + itemset);
			}

			// The elements of size N+1 are the previous elements of the
			// generation of elements of size N+2
			previousLevel = nextLevel;
		}

		// generate all possible rules
		log("There are " + allFrequents.size() + " frequent itemsets");
		log("Generating rules...");
		//int generatedRules = 0;
		/*List<Rule> ruleList = new ArrayList<Rule>();
		for (Itemset frequent : allFrequents) {
			for (Rule r : frequent.generateRules()) {
				double ruleConfidence = r.confidence();
				log("\t> Considering the rule " + r + "...");
				if (ruleConfidence >= confidence) {
					++generatedRules;
					log("\t\t=> Rule kept.");
					ruleList.add(r);
				} else {
					log("\t\t=> Confidence too low.");
				}
			}
		}
		log(generatedRules + " rules have been generated.");

		log("Total duration: " + ((System.currentTimeMillis() - begin) / 1000.)
				+ "s");
*/
		//return ruleList;
                Freq=allFrequents;
	return allFrequents;
        }



 //******************prunuing step***************/
boolean checked(Itemset I1, Itemset I2)
{
 String s1=I1.toString();
    String s2=I2.toString();

return s2.contains(s1);

}


int cover(int F[])
{
int t[]=new int[transactions.size()];

for (int i=0;i<transactions.size();i++)
{
t[i]=0;
}

for (int i=0;i<Freq.size();i++)
{
Itemset I1=new Itemset();
if (F[i]!=0){
I1=Freq.get(i);
for (int j=0;j<transactions.size();j++)
 {
   Itemset I2=new Itemset();
  I2=transactions.get(j);
  if (checked(I1, I2)==true)
  {
  t[j]=1;
  }
 }
    }
}
int s=0;
for (int i=0;i<transactions.size();i++)
{
s=s+t[i];
}
return s;
}

void InitialState()
{

for (int i=0;i<Freq.size();i++)
{
for (int j=0;j<Freq.size() && j!=i;j++)
{
S[j]=0;
}
S[i]=1;
Open.add(S);
}
}

void InitialState2()
{
Random r=new Random();
int i;
int l=Freq.size()/2;
//System.out.println(" l is "+l);
//int nb=0;

for (int j=0;j<Freq.size();j++)
{
S[j]=0;
}

for (int j=0;j<l;j++)
{
i=r.nextInt(Freq.size());
S[i]=1;
}

/*
while (i<Freq.size())
 {
     if (nb<l)
     {
S[i]=r.nextInt(2);
if (S[i]==1){nb++;}

 }
    
else {
S[i]=0;
}
     i++;
 }*/
Open.add(S);
}
void GenerateState(int S[])
{
    int i=0;
while (S[i]!=0)
{
i++;
}
 S[i]=1;   
Open.add(S);
}

int FirstStrategy()
{
int []S1=new int[1000];
InitialState2();
int iter=0;
boolean exit=false;
int cost=0;
while (Open.size()!=0 && exit==false && iter!=2)
{
    //System.out.println(Open.size());
S1=(int[]) Open.remove(0);
cost=cover(S1);
if (cost==transactions.size())
{
exit=true;
}
//System.out.println(Open.size());
GenerateState(S1);
iter++;
//System.out.println(Open.size());
}
System.out.println("**********First Strategy***************");
for (int i=0;i<Freq.size();i++)
{
    if (S1[i]!=0)
System.out.println(Freq.get(i).toString());
}
System.out.println();


return cost;
}

int countWords(String s){

    int wordCount = 0;

    boolean word = false;
    int endOfLine = s.length() - 1;

    for (int i = 0; i < s.length(); i++) {
        // if the char is a letter, word = true.
        if (Character.isLetter(s.charAt(i)) && i != endOfLine) {
            word = true;
            // if char isn't a letter and there have been letters before,
            // counter goes up.
        } else if (!Character.isLetter(s.charAt(i)) && word) {
            wordCount++;
            word = false;
            // last word of String; if it doesn't end with a non letter, it
            // wouldn't count without this.
        } else if (Character.isLetter(s.charAt(i)) && i == endOfLine) {
            wordCount++;
        }
    }
    return wordCount;
}
int NumberOfItems(String s)
    {
String[] Items = s.split(",");

  return Items.length;
    }

void SecondStrategy(int T)
{
for (int i=0;i<Freq.size();i++)
{
 String s=Freq.get(i).toString();
int x=NumberOfItems(s);
String ss=Freq.get(i).toString();
    if (x<T) {
        Specific.add(Freq.get(i));    
        //System.out.println(ss+" "+"Specific Trend");

    }
 else {
    General.add(Freq.get(i));
    //System.out.println(ss+" "+"General Trend");

    }


}

}


void ThirdStrategy()
{



}

int Sim(Itemset I1, Itemset I2)
{
    int nb=0;
 String s1, s2;
 String[] Items1, Items2;
 s1=I1.toString();
s2=I2.toString();
Items1=s1.split(",");
Items2=s2.split(",");
for (int i=0;i<Items1.length;i++)
{
 for (int j=0;j<Items2.length;j++)
 {
 if (Items1[i].compareTo(Items2[j])==0)
 {
  nb++;
 }
 }

}
return nb;
}

void init_centers(int k, List <Itemset> F)
{
    Random r=new Random();

for (int i=0; i<k;i++)
{
    int x=r.nextInt(F.size());
centers.add(F.get(x));
}

}

void grouping(List <Itemset> F, int k)
{
        Random r=new Random();
int cluster[]=new int[Freq.size()];
init_centers(k, F);

for (int i=0;i<F.size();i++)
{
int d=Sim(F.get(i), centers.get(0));
int c=0;

  for (int j=1;j<k;j++)
  {
      int s=Sim(F.get(i), centers.get(j));
   if (d<s)
   {
   d=s;
   c=j;
   }
 cluster[i]=c;
  }
}

for (int i=1;i<F.size();i++)
{
    if (cluster[i]==0) { cluster[i]=r.nextInt(k);}
}

for (int j=0;j<k;j++)
{
    System.out.println("*************Cluster "+ j +" *****************");
for (int i=1;i<F.size();i++)
{

    if (cluster[i]==j) {
        String s=F.get(i).toString();
        System.out.println(s);

                       }
}
    }
}


}
