/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package arm.apriori.core;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 *
 * @author mobntic
 */
public class GAApriori {
// The data source of the transactions. It's an object that can generate a
	// list of transactions.
	protected TransactionSource source;

	// The transactions generated by the source
	public List<Itemset> transactions;

	// A link to the GUI, so as to log informations.
	protected NewClass gui;

        List<String[]> candidates=new ArrayList<String[]>();
        List<Integer> freq=new ArrayList<Integer>();

	protected void log(String s) {
	//	gui.log(s);
        }

	public void setSource(TransactionSource transactionSource) {
		LabelsMap.getInstance().clear();
		SupportMap.clear();
		source = transactionSource;
	}

	public List<Itemset> getTransactions() {
		transactions = source.generate();
   		/*System.out.println("The following transactions have been loaded: ");
		for (Itemset i : transactions) {
			System.out.println("\t> " + i);
		}
                  */
		return transactions;
	}


int N=40;// number of items
int M=1000; // number of transactions
double MinSup=0.2;
int pop_size=100; // represents the number of individuals on the given population
int IMAX=8;
int trans[] =new int[N];
int nb;
List<solution> pop=new ArrayList<solution>();
List<solution> newpop=new ArrayList<solution>();


/****************Genetic algorithm*******/
void population_initialization()
{
//int s[]=new int[10000];
Random r=new Random();
solution s=new solution();
for (int i=0;i<pop_size;i++)
{
   for (int j=0;j<N;j++)
 {
  s.sol[j]=r.nextInt(2);
 }
   pop.add(s);
}
}

void Ipopulation_initialization()
{
Random r=new Random();
solution s=new solution();
for (int i=0;i<pop_size;i++)
{
    int index=r.nextInt(N);
    s.sol[index]=1;
   for (int j=0;j<N && j!=index;j++)
    {
      s.sol[j]=0;
    }
     pop.add(s);
}
}


void crossover()
{
Random r=new Random();
solution s1=new solution();
solution s2=new solution();
solution s3=new solution();
solution s4=new solution();
for (int i=0; i<pop_size-1;i=i+2)
  {
    s1=pop.get(i);
    s2=pop.get(i+1);
    int pc=r.nextInt(N);
   for (int j=0; j<pc;j++)
    {
      s3.sol[j]=s1.sol[j];
      s4.sol[j]=s2.sol[j];
    }

    for (int j=pc; j<N;j++)
    {
      s3.sol[j]=s2.sol[j];
      s4.sol[j]=s1.sol[j];
    }
    s3.cost=fitness1(s3.sol);
    s4.cost=fitness1(s4.sol);
    newpop.add(s3);
    newpop.add(s4);
    
  }
}

void Icrossover()
{
int index1=0, index2=0;
solution s1=new solution();
solution s2=new solution();
solution s3=new solution();
solution s4=new solution();
 for (int i=0; i<pop_size-1;i=i+2)
  {
          boolean trouve1=false, trouve2=false;
          s1=pop.get(i);
          s2=pop.get(i);
   for (int j=0; j<N;j++)
    {
       s3.sol[j]=s1.sol[j];
      if (s1.sol[j]!=0 && trouve1==false)
      {
      trouve1=true;
      index1=j;
      }
       s4.sol[j]=s2.sol[j];
      if (s2.sol[j]!=0 && trouve2==false)
      {
      trouve2=true;
      index2=j;
      }
    }
     s3.sol[index2]=1;
     s4.sol[index1]=1;
s3.cost=fitness1(s3.sol);
    s4.cost=fitness1(s4.sol);
    newpop.add(s3);
    newpop.add(s4);
  }
}

void mutation()
{
    Random r =new Random();
solution s1=new solution();
    for (int i=0; i<pop_size;i=i+1)
  {
   int pm=r.nextInt(N);
   s1=newpop.get(i);
   s1.sol[pm]=r.nextInt(3);
   s1.cost=fitness1(s1.sol);
   newpop.add(s1);
   }
}

void Imutation()
{
    solution s1=new solution();

for (int i=0; i<pop_size;i=i+1)
  {
   s1=newpop.get(i);
   if (s1.cost < MinSup)
   {
           boolean trouve1=false, trouve2=false;
           for (int j=0; j< N && (trouve1==false || trouve2==false); j++)
            {
            if (s1.sol[j]==1 && trouve1==false)
            {
             s1.sol[j]=0;
             trouve1=true;
            }

            if (s1.sol[j]==0 && trouve2==true)
            {
             s1.sol[j]=1;
             trouve2=true;
            }
            }
   }
    s1.cost=fitness1(s1.sol);
   newpop.add(s1);
   }
}

void reproduction()
{
for (int j=0;j<pop_size;j++)
{
float min=pop.get(0).cost;
int min_i=0;
  for (int i=1;i<pop_size;i++)
  {
     if(pop.get(i).cost<min)
      {
       min=pop.get(i).cost;
       min_i=i;
      }
  }
  if (pop.get(min_i).cost<newpop.get(j).cost)
  {
  for (int l=0;l<N; l++)
  {
  pop.get(min_i).sol[l]=newpop.get(j).sol[l];
  }
  pop.get(min_i).cost=newpop.get(j).cost;
  }
}
}

/*************************compute the support of the solution s**********/
float support_itemset(int s[])
{
float compt=0;
String arr[];
		for (int i=0; i<transactions.size(); i++)
		{
		boolean appartient=true;
		arr=transactions.get(i).toString().split(",");
                int nb = arr.length;
		int j=0;
		while (j<N)
		{
		 if (s[j]!=0)
		{
			int l=0;
			boolean existe=false;
			while (l< nb && existe==false)
			{ System.out.println(arr[l]);
				//if (=j+1)
				//{existe=true;}
			l++;
			}
			if (existe==false){appartient=false;}
		}
		j++;
		}
		if (appartient==true) {compt++;}
		}
       //printf("support rule is:%f\n",compt);
       compt=compt/M;

	return compt;
}
float fitness1(int s[])
{
	return support_itemset(s);
}

float average_fitness()
{
 float sum=0;
 for (int i=0;i<pop_size;i++)
  {
       sum=sum+pop.get(i).cost;
  }
  return(sum/pop_size);
}

/**********************copry t in v********/
void copy(int t[], int v[])
{
for (int i=0;i<N; i++)
{
v[i]=t[i];
}
}
/**************************display_solution*****************/
void display_solution(solution S)
{
for (int i=0;i<N;i++)
{
    System.out.println(S.sol[i]);
}

}


/*****************************display T_dance************/
void display_pop()
{

for (int i=0;i<pop_size;i++)
{
    for (int j=0;j<N;j++)
    {

    System.out.print(pop.get(i).sol[j]+" ");
    }
    System.out.println(pop.get(i).cost);
}
}

/*****************************display transactions************/
void display_transactions()
{
String arr[];
for (int i=0;i<transactions.size();i++)
{
    arr=transactions.get(i).toString().split(",");
                int nb = arr.length;
                for (int j=0;j<nb;j++)
                {
		 System.out.print(arr[j]+" ");
                }
		System.out.println();
}
    }
void main_process()
{
    display_transactions();
/*int i,j;
     Ipopulation_initialization();
     i=0;
     while(i<IMAX)
     {
     Icrossover();
     Imutation();
     reproduction();
     i++;
     }
      System.out.println("the average fitness is:"+average_fitness());
}*/
}
}

